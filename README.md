# 재입고 알림 시스템

## 1. 프로젝트 소개

상품이 재입고되었을 때, 해당 상품의 알림을 설정한 사용자에게 알림 메시지를 전송하는 시스템입니다.
재고가 소진될 경우 알림 발송이 중단되며, 회차별 알림 발송 상태를 자동으로 기록합니다.
마지막 알림을 보낸 유저 이후부터 알림을 재발송할 수 있습니다.
알림 발송은 초당 최대 500개까지로 제한합니다.

---

## 2. 기술 스택

- **Backend**: Spring Boot, Java 17
- **Database**: MySQL 8.0
- **Build & Deployment**: Gradle, Docker Compose
- **Libraries**:
    - Google Guava: RateLimiter를 이용한 초당 요청 제한
    - Spring Data JPA
- **Testing**: JUnit 5, Mockito

---

## 3. 핵심 기능

1. **재입고 알림 발송**
    - 상품의 재입고 회차를 증가시킨 후, 알림을 설정한 유저들에게 알림 메시지를 순차적으로 전송합니다.
    - 알림 전송 시 초당 **500개** 요청 제한을 적용합니다.
2. **재고 소진 또는 예외 발생 시 알림 중단**
    - 알림 전송 중 재고가 소진되면 알림 전송을 중단하고 상태를 기록합니다. (IN_PROGRESS -> CANCELED_BY_SOLD_OUT)
    - 알림 전송 중 예외가 발생할 경우 알림 전송을 중단하고 상태를 기록합니다. (IN_PROGRESS -> CANCELED_BY_ERROR)
3. **알림 발송 이력 저장**
    - 상품별 재입고 회차, 알림 상태, 마지막 발송 유저 정보를 기록합니다.
    - 각 유저에게 발송된 알림 이력도 저장합니다.
4. **중단 이후부터 재전송 가능**
    - 재고 소진 또는 예외로 인해 알림이 중단된 경우, 마지막 알림을 보낸 유저 이후부터 알림을 재발송할 수 있습니다.

---

## 4. 데이터베이스 설계
![ERD](https://github.com/user-attachments/assets/91316687-5b0f-413a-9138-8a7f4b05f7eb)

---

## 5. 기술적 의사결정

### 1. **알림 발송 속도 제한**

알림 메시지는 초당 500개까지만 전송해야 하는 비즈니스 요구사항이 있었습니다.
- 초기에는 Thread.sleep()을 사용하여 1초 대기하도록 했으나, 병렬 처리 불가, 정확성 부족 문제가 있어 변경했습니다.
- RateLimiter, RateLimitJ, Bucket4j 중 **RateLimiter**를 사용하여 초당 요청 제한을 구현하였습니다.
- 현재 요구사항에서는 분산 처리 요구사항이 없었고, 정확하게 초당 500개 알림을 보낼 수 있었기 때문에 RateLimiter를 선택했습니다.

### 2. **트랜잭션 관리 최적화**

- 로직을 고려하여 메서드 레벨에서 @Transactional을 선언하였고, 필요한 경우에만 클래스 레벨에서 선언하였습니다.
- 단순 조회만 하는 메서드는 @Transactional(readOnly = true)를 사용해 성능과 효율성을 고려하였습니다.
- Isolation Level을 Read Committed로 변경하고, 서비스 메서드를 분리하여 트랜잭션 범위를 최소화하였습니다.

### 3. **비관적 락을 통한 동시성 제어**

- Optimistic Lock보다 Pessimistic Lock을 사용하여 재입고 회차와 알림 상태 데이터의 정합성을 보장했습니다.
- Optimistic Lock을 사용할 경우 성능이 조금 더 좋아질 수 있지만, 해당 프로젝트에서는 충돌이 발생할 경우 자주 롤백할 것 같아 사용하지 않았습니다.
- 대신 해당 프로젝트는 동시에 수정될 가능성이 높고 데이터 정합성이 중요한 프로젝트라고 판단하여 Pessimistic Lock를 사용하였습니다.

### 4. **인덱스 최적화**

- 상품 아이디(product_id)와 id를 사용하여 정렬하는 쿼리에서 복합 인덱스를 사용해 대용량 데이터 조회 성능을 개선했습니다.

---

## 6. 실행 방법

### **1. 환경 준비**
- **Docker**와 **Docker Compose**가 설치되어 있어야 합니다.
    - Docker 설치: [링크](https://docs.docker.com/get-docker/)
    - Docker Compose 설치: [링크](https://docs.docker.com/compose/install/)
- DB는 컨테이너 시작 시 자동으로 생성됩니다.
- 애플리케이션은 http://localhost:8083/ 에서 실행됩니다.
